The first things done is this episode are changes to a few settings in the project:
- The first is to enable randomization of execution order of the tests to ensure that there is not some hidden sequential dependency. We want our tests to run perfectly in isolation as well as in a group. If one test fails, all the reasons for its failure should be contained within its own scope / method definition. It's possible to have scenarios where either tests fail in isolation but pass integration, or the opposite. We want to avoid this kind of flaky test suite condition and randomizing the execution helps with this.
- It was also discussed whether to activate the parallelization option but since we don't have performance issues with our tests at the moment, this is not necessary.
- We enable gathering the code coverage option for our essential feed target. When we run our tests this returns 100%. It is important to note that this metric simply reports which lines of our production code were executed while running the tests. It does not mean we have covered all possible scenarios and behaviours. So this means that 100% of our lines were executed while running our tests. So code coverage is not the goal, it's a side effect of TDD. Coverage will typically be 100% with TDD as we are enumerating our cases ans creating assertions for them first before writing the production code. The true goal of TDD is to have confidence that we have tested the important behaviours and that we are free to change our code. This means we will be agile and able to adapt to change and prevent bugs. 